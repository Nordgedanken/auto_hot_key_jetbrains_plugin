{
  parserClass="de.nordgedanken.auto_hotkey.lang.parser.AhkParser"

  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'

  psiClassPrefix="Ahk"
  psiImplClassSuffix="Impl"
  psiPackage="de.nordgedanken.auto_hotkey.lang.psi"
  psiImplPackage="de.nordgedanken.auto_hotkey.lang.psi.impl"

  elementTypeHolderClass="de.nordgedanken.auto_hotkey.lang.psi.AhkTypes"
  elementTypeClass="de.nordgedanken.auto_hotkey.lang.psi.AhkElementType"
  tokenTypeClass="de.nordgedanken.auto_hotkey.lang.psi.AhkTokenType"

  psiImplUtilClass="de.nordgedanken.auto_hotkey.lang.psi.impl.AhkPsiImplUtil"

  tokens = [
    //generic
    CHAR_SPECIAL = "regexp:\p{Punct}"
    CRLF = "regexp:[\n\r\f]"
    WHITESPACE = "regexp:\p{Blank}+" //reads same-line whitespace only, since AHK requires whitespace/LF in certain places

    //language-specific

    //built-ins
    id="regexp:\w+"
  ]
}

/*
    Naming convention:
    - psiElements are camelcase
    - tokens are lowercase: for, if, identifier
    - rules are PascalCase: StructItem, EnumVariant
    - recovery related rules are PascalCase_with_snake_suffix: Item_recover
*/

AhkFile ::= Item*
private Item ::= Function_Decl | Text | CRLF

private Function_Decl ::= Hotkey_Decl
private Hotkey_Decl ::= WHITESPACE? Hotkey_Assignment
Hotkey_Assignment ::= Hotkey ':' ':' //NOTE: Temporarily set as 2 tokens to allow parsing of :: in other strings. Will be combined in later improvements
Hotkey ::= ('#'|'!'|'^'|'+'|'<'|'>'|'<^>!'|'*'|'~'|'$')* (id | CHAR_SPECIAL) (WHITESPACE '&' WHITESPACE (id | CHAR_SPECIAL))? (WHITESPACE 'Up')?

private Text ::= (Word | CHAR_SPECIAL | WHITESPACE)+
Word ::= id

//hotkeyAssignment ::= HOTKEY_ASSIGNMENT
//property ::= (KEY? SEPARATOR VALUE?) | KEY {
//    pin=3
//    recoverWhile="recover_property"
//}
//private recover_property ::= !(KEY|SEPARATOR|COMMENT)

//A hotkey is made of 0+ modifiers and at least 1 character.
// Modifiers must appear before characters. You can repeat modifiers (though it's pointless).
// Custom combinations can be 2 keys only and must have " & " between them.
//HOTKEY_ASSIGNMENT ::= ('#'|'!'|'^'|'+'|'<'|'>'|'<^>!'|'*'|'~'|'$')* ALPHANUMERIC_OR_SPACE+ (' & ' ALPHANUMERIC_OR_SPACE+)? '::'

/*
ahkFile ::= Items*

private Items ::= Item_with_recover*
private Item_with_recover ::= !('}' | <<eof>>) Item {
  pin = 1
  recoverWhile = Item_recover
}

private Item_recover ::= !('}' | Item )


fake Block ::= '{' (Item)* Expr? '}' {
  pin = 1
  implements = "de.nordgedanken.auto_hotkey.psi.ext.AHKItemsOwner"
  extends = "de.nordgedanken.auto_hotkey.psi.ext.AHKStubbedElementImpl<?>"
  stubClass = "de.nordgedanken.auto_hotkey.ide.stubs.AHKPlaceholderStub"
  elementTypeFactory = "de.nordgedanken.auto_hotkey.ide.stubs.StubImplementationsKt.factory"
}

SimpleBlock ::= '{' BlockElement* '}' {
  pin = 1
  elementType = Block
}

Stmt ::= property {
  mixin = "de.nordgedanken.auto_hotkey.psi.ext.AHKStmtMixin"
}
AnyExpr ::= (STRING_LITERAL|NUMBERS|identifier|expression_script_block|FUNCTION_CALL) {
   elementType = Expr
   name = "expr"
 }
fake ExprStmt ::= AnyExpr { extends = Stmt }
upper ExprStmtUpper ::= () (<<isBlock>>) { pin = 1 elementType = ExprStmt }
ExprStmtOrLastExpr ::= &'}' | ExprStmtUpper {
  elementType = Expr
}
private BlockElement ::= !'}' ( variable | Item | ExprStmtOrLastExpr) {
  pin = 1
  recoverWhile = BlockElement_recover
}

private Expr_first ::= Return | '{' | '(' | true | false | if | for | continue | break  | loop | match | AnyLitToken

private BlockElement_recover ::= !('}' | Expr_first)

SimpleBlock ::= '{' BlockElement* '}' {
  pin = 1
  elementType = Block
}
    BlockExpr ::= [ &'{' ] SimpleBlock {
  implements = [ "de.nordgedanken.auto_hotkey.psi.ext.AHKLabeledExpression"]
  elementTypeFactory = "de.nordgedanken.auto_hotkey.ide.stubs.StubImplementationsKt.factory"
}

RetExpr ::= Return Expr? {
  elementTypeFactory = "de.nordgedanken.auto_hotkey.ide.stubs.StubImplementationsKt.factory"
}

Expr ::= RetExpr
         | BlockExpr {
                    mixin = "de.nordgedanken.auto_hotkey.psi.ext.AHKExprMixin"
                    stubClass = "de.nordgedanken.auto_hotkey.ide.stubs.AHKPlaceholderStub"
                  }

LitExpr ::= AnyLitToken {
 elementTypeFactory = "de.nordgedanken.auto_hotkey.ide.stubs.StubImplementationsKt.factory"
 implements = [ "com.intellij.psi.PsiLanguageInjectionHost"
                "com.intellij.psi.ContributedReferenceHost" ]
 mixin = "de.nordgedanken.auto_hotkey.psi.ext.AHKLitExprMixin"
}

private AnyLitToken ::=   STRING_LITERAL
                        | INTEGER_LITERAL {
  consumeTokenMethod = "consumeTokenFast"
}

//TODO might need to be revisited
InnerAttrsAndBlock ::= '{' '}' {
  pin = 1
  elementType = Block
}

//XXX: don't use contextual keywords in recover, because they remap tokens.
private default_ ::= <<defaultKeyword>>

private ShallowBlock ::= <<parseCodeBlockLazy>>

    PatBinding ::= identifier  !ForbiddenPatBindingLast {
  implements = [ "de.nordgedanken.auto_hotkey.psi.ext.AHKMandatoryReferenceElement" ]
  mixin = "de.nordgedanken.auto_hotkey.psi.ext.AHKPatBindingImplMixin"
}

private ForbiddenPatBindingLast ::= '(' | '{' | '!' {
  consumeTokenMethod = "consumeTokenFast"
}

PatIdent ::= PatBinding

Pat ::= PatIdent {
  name = "pattern"
}

FnParameter ::= [Pat]

private Path_first ::= identifier
private Pat_first ::= '(' | '[' | Path_first | AnyLitToken
private FnParameter_recover ::= !(Pat_first | ')')
private FnParameter_with_recover ::= !')' FnParameter (',' | &')') {
  pin = 2
  recoverWhile = FnParameter_recover
}

FnParameters          ::= '(' !','
                           FnParameter_with_recover*
                          ')' { pin = 1 }

Function ::= identifier
             FnParameters
             ShallowBlock?
{
  pin = 'identifier'
  name = ""
  implements = ["de.nordgedanken.auto_hotkey.psi.ext.AHKItemElement"
                "de.nordgedanken.auto_hotkey.psi.ext.AHKNamedElement"
                ]
  mixin = "de.nordgedanken.auto_hotkey.psi.ext.AHKFunctionImplMixin"
  stubClass = "de.nordgedanken.auto_hotkey.ide.stubs.AHKFunctionStub"
  elementTypeFactory = "de.nordgedanken.auto_hotkey.ide.stubs.StubImplementationsKt.factory"
}

Item ::= default_? (FUNCTION_CALL
         | C_COMMENT_FULL
         | HOTKEY
         | variable
         | RetExpr
         | key_list
         | Function
         | STRING_LITERAL
         | expression_script_block
         | HEX
         | INT_LITERAL) {
    name = "item"
    elementType = ToBeUpped
    hooks = [ leftBinder = "ADJACENT_LINE_COMMENTS" ]
}

key_list ::= ((identifier|INT_LITERAL|STRING_LITERAL|EXPRESSION_SCRIPT) COMMA)+ (identifier|INT_LITERAL|STRING_LITERAL|EXPRESSION_SCRIPT)?

variable ::= identifier VAR_ASIGN AnyExpr {
  extends = Stmt
  pin = "property"
}

expression_script_block ::= (EXPRESSION_SCRIPT (STRING_LITERAL|INT_LITERAL|identifier) EXPRESSION_SCRIPT)

HOTKEY ::= ("#"|"!"|"^"|"+"|"&"|"<"|">"|"<^>!"|"*"|"~"|"$")? ANY_CHAR "::"

HEX ::= HEX_DEF

FILENAME ::= identifier DOT identifier


//HOTKEY ::= ("#"|"!"|"^"|"+"|"&"|"<"|">"|"<^>!"|"*"|"~"|"$")? ANY_CHAR "::"
*/
