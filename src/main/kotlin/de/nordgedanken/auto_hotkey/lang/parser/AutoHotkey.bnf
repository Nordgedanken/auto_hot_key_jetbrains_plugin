{
  parserClass="de.nordgedanken.auto_hotkey.lang.parser.AhkParser"

  extends='com.intellij.extapi.psi.ASTWrapperPsiElement'

  psiClassPrefix="Ahk"
  psiImplClassSuffix="Impl"
  psiPackage="de.nordgedanken.auto_hotkey.lang.psi"
  psiImplPackage="de.nordgedanken.auto_hotkey.lang.psi.impl"

  elementTypeHolderClass="de.nordgedanken.auto_hotkey.lang.psi.AhkTypes"
  elementTypeClass="de.nordgedanken.auto_hotkey.lang.psi.AhkElementType"
  tokenTypeClass="de.nordgedanken.auto_hotkey.lang.psi.AhkTokenType"

  tokens = [
    //Ahk-specific
    CHAR_SPECIAL="regexp:\p{Punct}"
    TEXT="regexp:\p{Alnum}+"

    //generic
    /*
      Note that since WHITESPACE_HOZ is marked as "PsiWhiteSpace", the parser ignores it so we do not need to specify
      it within the bnf rules. (We return TokenType.WHITE_SPACE in lexer because GrammarKit will not generate
      the WHITESPACE_HOZ token class otherwise)
    */
    WHITESPACE_HOZ="regexp:\p{Blank}+"
    CRLF="regexp:\v"
    /**
      All line comments after code must be preceded by whitespace, so specifying the regex
      here would not work. (Eg: " hel;lo" and " ;test" would parse as a comment
      even though it is actually a one-word string and whitespace + comment,
      respectively. Instead, the lexer handles this logic.
      See https://www.autohotkey.com/docs/Language.htm#comments
     */
    LINE_COMMENT
    /** Block comment begin/end chars must appear at the beginning of the line */
    BLOCK_COMMENT
  ]
}

/*
  Naming convention:
  - psiElements are camelcase
  - tokens are lowercase: for, if, identifier
  - rules are PascalCase: StructItem, EnumVariant
  - recovery related rules are PascalCase_with_snake_suffix: Item_recover
*/

AhkFile ::= Item*
private Item ::= Line | BLOCK_COMMENT | LINE_COMMENT | CRLF //Note that only CRLF can follow a line comment

/* We check for whitespace before the comment via the lexer.
The parser will ignore all PsiWhitespace elements during ast verification.
(so it's like we're really doing (WHITESPACE_HOZ LINE_COMMENT?)? at the end instead)
 */
Line ::= (TEXT | CHAR_SPECIAL)+ LINE_COMMENT?
